name: Build RPM

on:
  push:
    tags:
      - '**[0-9]+.[0-9]+.[0-9]+*'
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to upload RPM to (e.g. v0.0.4). Optional."
        required: false
        type: string

jobs:
  build_rpm:
    runs-on: ubuntu-latest
    container: fedora:latest
    permissions:
      contents: write # Needed to upload to release

    steps:
      - name: Resolve ref/tag context
        id: meta
        shell: bash
        run: |
          set -euo pipefail

          CHECKOUT_REF="${GITHUB_REF}"
          RELEASE_TAG=""
          UPLOAD="false"

          if [[ "${{ github.event_name }}" == "release" ]]; then
            RELEASE_TAG="${{ github.event.release.tag_name }}"
            CHECKOUT_REF="${RELEASE_TAG}"
            UPLOAD="true"
          elif [[ -n "${{ inputs.tag }}" ]]; then
            RELEASE_TAG="${{ inputs.tag }}"
            CHECKOUT_REF="${RELEASE_TAG}"
            UPLOAD="true"
          elif [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            RELEASE_TAG="${GITHUB_REF_NAME}"
            UPLOAD="true"
          fi

          echo "checkout_ref=${CHECKOUT_REF}" >> "$GITHUB_OUTPUT"
          echo "release_tag=${RELEASE_TAG}" >> "$GITHUB_OUTPUT"
          echo "upload_to_release=${UPLOAD}" >> "$GITHUB_OUTPUT"

          echo "checkout_ref=${CHECKOUT_REF}"
          echo "release_tag=${RELEASE_TAG}"
          echo "upload_to_release=${UPLOAD}"

      # Install git and build dependencies. Fedora's minimal image may not have them.
      - name: Install dependencies
        run: |
          dnf install -y git rpm-build rust cargo tar gzip openssl-devel gh

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.meta.outputs.checkout_ref }}

      - name: Prepare Source
        run: |
          # Extract version from Cargo.toml
          VERSION=$(grep '^version =' Cargo.toml | head -n1 | cut -d '"' -f 2)
          echo "Detected version: $VERSION"
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          
          # Prepare directory for archiving to match %setup -q in the spec file.
          # Use a temp directory to avoid self-referencing.
          mkdir -p /tmp/jico-$VERSION
          cp -r . /tmp/jico-$VERSION/
          rm -rf /tmp/jico-$VERSION/.git
          
          # Create tarball in the current working directory
          tar -czf jico-$VERSION.tar.gz -C /tmp jico-$VERSION
          
          # Setup rpmbuild directory structure
          mkdir -p ~/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
          mv jico-$VERSION.tar.gz ~/rpmbuild/SOURCES/

      - name: Build RPM
        run: |
          # Run rpmbuild, passing the extracted version
          rpmbuild -ba packaging/jico.spec --define "version ${{ env.VERSION }}"

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: jico-rpm
          path: ~/rpmbuild/RPMS/**/*.rpm

      - name: Upload RPM to Release
        if: steps.meta.outputs.upload_to_release == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.meta.outputs.release_tag }}"

          # On tag-push runs, release creation may still be in progress.
          # Wait a bit so upload doesn't fail with "release not found".
          if [[ "${{ github.event_name }}" != "release" ]]; then
            for i in $(seq 1 30); do
              if gh release view "$TAG" >/dev/null 2>&1; then
                break
              fi
              echo "Release $TAG not found yet (attempt $i/30), waiting..."
              sleep 10
            done
            gh release view "$TAG" >/dev/null 2>&1
          fi

          # Find the RPM file
          RPM_FILE=$(find ~/rpmbuild/RPMS -name "*.rpm" | head -n 1)
          echo "Found RPM: $RPM_FILE"
          
          # Upload to the release that triggered this workflow
          gh release upload "$TAG" "$RPM_FILE" --clobber
